---
title: "MB2 Pupillometry Analysis"
format: html
---

```{r}
# Clear work space:
rm(list = ls())

library(tidyverse)
library(here)
library(glue)
library(assertthat)

source(here('helper','ensure_repo_structure.R'))
plot_path <- here("plots")

# load(here(INTERMEDIATE_FOLDER, INTERMEDIATE_006)) # if we want data post-exclusion
load(here(INTERMEDIATE_FOLDER, INTERMEDIATE_006b)) # if we want data pre-exclusion # Need to change l. 28, too.
```

Basic cleaning: 
1. Remove all web-based data.
2. Create `pupil_size` column which should be the mean of `pupil_left` and `pupil_right` (liberal average).
3. For cases in which `x` and `y` are NA, `pupil_size` should be NA, not 0.

```{r}
data_pupillometry <- data_preprocessed |> 
  filter(data_type=="in-lab") |> 
  mutate(pupil_left = ifelse(is.na(x) & is.na(y), NA, # If both x and y are NA, pupil_left should be NA, not 0
                          ifelse(is.na(pupil_left), pupil_right, pupil_left)), # If pupil_left is NA, take value of pupil_right
         pupil_right = ifelse(is.na(x) & is.na(y), NA, # If both x and y are NA, pupil_right should be NA, not 0
                          ifelse(is.na(pupil_right), pupil_left, pupil_right))) # If pupil_right is NA, take value of pupil_left
```

```{r}
# Clear workspace and keep only relevant files
rm(list = setdiff(ls(), c("data_pupillometry", "INTERMEDIATE_FOLDER", "INTERMEDIATE_008")))
```

Sanity check.
Some EyeLink-labs have long right tails; Nijmegen also has some density in the very low sizes that might be artefacts

```{r}
data_pupillometry |> 
  filter(age_cohort == "adults") |> 
  ggplot() +
  geom_density(aes(x = pupil_left, col = lab_id)) +
  theme_classic() +
  theme(legend.position = "none") +
  facet_wrap(~ lab_id, scales = "free")

data_pupillometry |> 
  filter(age_cohort == "adults") |> 
  ggplot() +
  geom_density(aes(x = pupil_right, col = lab_id)) +
  theme_classic() +
  theme(legend.position = "none") +
  facet_wrap(~ lab_id, scales = "free")
```

```{r}
data_pupillometry |> 
  filter(age_cohort == "toddlers") |> 
  ggplot() +
  geom_density(aes(x = pupil_left, col = lab_id)) +
  theme_classic() +
  theme(legend.position = "none") +
  facet_wrap(~ lab_id, scales = "free")

data_pupillometry |> 
  filter(age_cohort == "toddlers") |> 
  ggplot() +
  geom_density(aes(x = pupil_right, col = lab_id)) +
  theme_classic() +
  theme(legend.position = "none") +
  facet_wrap(~ lab_id, scales = "free")
```

(To note: Might need to consider deblinking and detransienting to remove artifacts (a lot of the low-value responses are surrounding NA instances); perhaps with a window of 25ms or 50ms.)

The pupillometry analyses are performed on the second test trial only:

```{r}
summarized_valid_second_test_trials <- data_pupillometry |> 
  filter(condition %in% c("ignorance","knowledge"),
         trial_num == 6) |> 
  mutate(
    valid_second_test_trial = case_when(
      trial_error == "no" ~ 1,
      trial_error == "yes" ~ 0,
      TRUE ~ NA
    )
  ) |> 
  select(lab_id, participant_lab_id, participant_id, 
         age_cohort, valid_second_test_trial) |> 
  distinct()

data_pupillometry <- data_pupillometry |> 
  left_join(summarized_valid_second_test_trials,
            by = join_by(participant_lab_id, participant_id, 
                         lab_id, age_cohort)) |> 
  mutate(valid_second_test_trial = ifelse(is.na(valid_second_test_trial), 
                                          0, valid_second_test_trial))

# validate
assert_that(sum(is.na(data_pupillometry$valid_second_test_trial)) == 0)
```

Merge in eyetracker info + Create new variable that contains eyetracker info: Eyelink, Tobii, or SMI.

```{r}
dataset_sheet <- read_csv(here("metadata", "dataset_sheet.csv"))
data_pupillometry <- data_pupillometry |> 
  mutate(data_id = glue("{lab_id}_{age_cohort}")) |> 
  left_join(dataset_sheet |> select(data_id, tracker_type),
            by = join_by(data_id)) |> 
  select(-data_id)
  # The above creates two columns, tracker_type.x & tracker_type.y
  # Check that they are identical:
  identical(data_pupillometry[['tracker_type.y']],data_pupillometry[['tracker_type.x']])
  # Then use one of them:
  data_pupillometry <- data_pupillometry |>
  mutate(eyetracker_type = str_remove(tracker_type.y, " .*"))
```

Create new variable that contains outcome info: congruent, incongruent.

```{r}
data_pupillometry$outcome <- ifelse(grepl("_CON$", data_pupillometry$media_name), "congruent",
                     ifelse(grepl("_INC$", data_pupillometry$media_name), "incongruent", NA))
```

Saving pupillometry dataset to use for multiverse:

```{r}
save(data_pupillometry, file = here(INTERMEDIATE_FOLDER, INTERMEDIATE_008))
```

# Create looking time dataset

## Select relevant trials/ window

- only second trial
- window: 0-60s post outcome

```{r}
data_voe <- data_pupillometry %>%
  filter(
    trial_num == 6, #second trial only
    t_norm >= 0 & t_norm <= 60000 #0-60s window post outcome
  )

## specify grouping parameters (add to this as needed)
grouping_params <- quos(age_cohort,participant_lab_id, lab_id,participant_id, participant_trial_id, trial_num, trial_file_name,media_name, condition, outcome, has_ending,target_side,eyetracker_type,trial_error,trial_error_type,total_valid_fam_trials,sufficient_fam_trials,valid_first_test_trial,trial_based_participant_exclusion,trial_based_participant_exclusion_type,pilot,session_error,session_error_info,exclude_session,valid_second_test_trial)

```

## Convert to RLE

This format creates a look-based format (each row represents the duration of a cluster of looking, in sequence, e.g. duration of look to one AOI) based on the AOIs predefined in the main analysis.

```{r}


# convert to rle data
rle_data_voe <- data_voe %>%
  group_by(
    !!!grouping_params
  ) %>%
  reframe(
    lengths = rle(aoi)$lengths,
    values = rle(aoi)$values
  ) %>%
  #convert to ms
  mutate(
    times = lengths * 25 #25ms samples
  ) %>%
  #on-screen looking
  mutate(
    onscreen_looking = ifelse(values == "NA_NA","off","on"),
    onscreen_looking_index = ifelse(values == "NA_NA",0,1)
  ) %>%
  #compute cumulative on-screen looking time within a trial
  mutate(
    cum_looking_time = cumsum(onscreen_looking_index * times),
    cum_total_time = cumsum(times)
  ) 
```

## Convert to on-screen looking time data

This format creates a look-based format based only on whether looking was on or off screen (each row represents the duration of a cluster of looking to the screen or off-screen).

```{r}
lt_data_voe <- data_voe %>%
  #on-screen looking
  mutate(
    onscreen_looking = ifelse(aoi == "NA_NA","off","on")
  ) %>%
  group_by(
    !!!grouping_params
  ) %>%
  reframe(
    lengths = rle(onscreen_looking)$lengths,
    values = rle(onscreen_looking)$values
  ) %>%
  #convert to ms
  mutate(
    times = lengths * 25 #25ms samples
  ) %>%
  mutate(
    onscreen_looking_index = ifelse(values == "off",0,1)
  ) %>%
  group_by(
    age_cohort, participant_lab_id, lab_id,
    participant_id, participant_trial_id, trial_num) %>%
  #compute cumulative on-screen looking time within a trial
  mutate(
    cumulative_looking_time = cumsum(onscreen_looking_index * times),
    #cumulative total time
    cumulative_total_time = cumsum(times)
  ) %>%
  #cumulative number of distinct on-screen looks
  mutate(
    cumulative_number_of_onscreen_looks = cumsum(ifelse(values == "on",1,0))
  )

#store dataset
save(lt_data_voe, file = here(INTERMEDIATE_FOLDER, "008-looking-time-data-unfiltered.Rds"))
```

## Implement criteria

As an example, I implement the criteria (look-away criterion, required cumulative looking, max looking time) from the first preregistered analysis.

```{r}
look_away_criterion <- 2000
cumulative_looking_required <- 2000
max_looking_time <- 30000
lt_data_voe_criterion <- lt_data_voe %>%
  #look away criterion: if children looked for longer than X seconds
  #set flag for looks offscreen longer than criterion
  mutate(
    look_away = case_when(
      values == "off" & times >= look_away_criterion ~ 1,
      TRUE ~ 0
    ),
    # only count look aways post sufficient looking
    look_away_post_suff_looking = case_when(
      look_away == 1 & cumulative_looking_time >= cumulative_looking_required ~ 1,
      TRUE ~ 0
    )) %>%
  # Cumulative group index that increments on each look away
  mutate(
    look_away_count = cumsum(lag(look_away, default = FALSE)),
    look_away_count_post_suff_looking = cumsum(lag(look_away_post_suff_looking, default = FALSE))) %>%
  # if there has been a look away AND there is sufficient existing cumulative looking, truncate
  filter(
    look_away_count_post_suff_looking == 0
  ) %>%
  # truncate at max time
  mutate(
    cumulative_total_looking_time_truncated_at_max = pmin(cumulative_looking_time, max_looking_time)
  ) %>%
  filter(lag(cumulative_looking_time) <= max_looking_time)

#summarize final looking times by participant
total_participant_lt_data_voe_criterion <- lt_data_voe_criterion %>%
  group_by(
    !!!grouping_params
  ) %>%
  summarise(
    total_look_aways_pre_criterion = max(look_away_count),
    total_cumulative_looking_time = max(cumulative_total_looking_time_truncated_at_max),
    total_screen_time = max(cumulative_total_time)
  )
```

## Quick summary and overview

```{r}
#visualize basic looking time distributions
ggplot(total_participant_lt_data_voe_criterion,aes(total_cumulative_looking_time, color=outcome))+
  geom_density()+
  facet_wrap(~condition+age_cohort)

#summarize by participant
avg_lt_data_voe_criterion <- total_participant_lt_data_voe_criterion %>%
  ungroup() %>%
  group_by(age_cohort,condition,outcome) %>%
  summarize(
    mean_looking_time = mean(total_cumulative_looking_time),
    sd_looking_time = sd(total_cumulative_looking_time),
    n = n(),
    se_looking_time = sd_looking_time / sqrt(n),
    ci_lower = mean_looking_time - qt(1 - (0.05 / 2), n - 1) * se_looking_time,
    ci_upper = mean_looking_time + qt(1 - (0.05 / 2), n - 1) * se_looking_time
  )

#visualize average effects
library(gghalves)
library(cowplot)
ggplot(
  total_participant_lt_data_voe_criterion,
  aes(x = outcome, y = total_cumulative_looking_time, color = outcome)
) +
  geom_jitter(width=0.05,height=0.025,alpha=0.3,stroke=NA)+
  geom_half_violin(
    aes(fill = outcome), side = "l", nudge = 0.2, width = 0.4, alpha = 0.2
  ) +
  stat_summary(fun.data = "mean_cl_boot", size = 1, position=position_nudge(x = .2, y = 0)) +
  theme_cowplot() +
  ylab("Total Looking Time (ms)")+
  scale_color_brewer(palette = "Dark2") +
  scale_fill_brewer(palette = "Dark2") +
  facet_wrap(~condition+age_cohort) +
  theme(legend.position = "none") 

#old: more basic bar plot
# ggplot(avg_lt_data_voe_criterion,aes(x=outcome,y=mean_looking_time, fill=outcome))+
#   geom_bar(stat="identity", position=position_dodge())+
#   geom_errorbar(aes(ymin=ci_lower, ymax=ci_upper), width=0.2, position=position_dodge(0.9))+
#   facet_wrap(~condition+age_cohort)
```



# Heatmaps

Creating heatmaps for 5s-window after the point of disambiguation
```{r}
library(png)
img.r <- as.raster(readPNG(here('helper', 'stim.png')),interpolate=F)

MB2P_DIR <- here('MB2P')
CHECKING_DIR <- here(MB2P_DIR, 'manual_data_checking_pupil')
CHECKING_HEATMAP_DIR <- here(CHECKING_DIR, 'heatmaps_for_pupil')

data_pupillometry %>% 
  filter((trial_num %in% c('6'))) %>% 
  filter(t_norm>=0 & t_norm<=5000)  %>%
  group_by(lab_id, media_name) %>%
  group_walk(function(data, grouping){
    print(grouping$lab_id)
    
    #if(!(grouping$lab_id %in% labs_to_check)){
    #  return(NA)
    #}
    
    labdir = here(CHECKING_HEATMAP_DIR, grouping$lab_id)
    dir.create(labdir, showWarnings = FALSE)
    tryCatch(
    ggsave(
      here(labdir, paste0(grouping$media_name, '__', grouping$lab_id, '.png')),
      plot = 
        ggplot(data, aes(x,y)) + 
          annotation_raster(img.r, xmin=-Inf, xmax=Inf, ymin=-Inf, ymax=Inf)+
          stat_density2d(geom = "polygon", aes(fill=..level.., alpha = ..level..), size= 20, bins= 500) + 
          scale_fill_gradient(low="blue",high="red") +
          scale_alpha_continuous(range=c(0.01,1.0), guide = FALSE) +
          scale_x_continuous(limits=c(0,dim(img.r)[2]),expand=c(0,0))+
          scale_y_continuous(limits=c(0,dim(img.r)[1]),expand=c(0,0))+
          coord_fixed(),
      width = 7,
      height = 5,
      units = "in"
      ), error = function(e) print(e))
  })
```